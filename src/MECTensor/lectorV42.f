cccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  Calculates the contribution of 2p2h to the double differential
c cross section d2sigma/(dTmu dcos_mu), units 10^{-41} cm^2/GeV
c from the GRID generated by MEC6Tensor code
c useful to settle normalization
c  
c  CAREFUL!, all options should be same as for GRID's generation
c            notice that same GRID is valid for nu and nubar
c  COMMENTS:
c      MAIN CODE: reads GRID+options, sets Q-value
c      diffCrossSection: for a given Muon kin. Energy and cosinus
c                        1.- gets the fourmomentum q
c                        2.- uses HadTensorW to get the Hadronic Tensor
c                        3.- constructs the 5 structure functions Wn
c                        using Eq. 9 from
c                        PRC70 (2004) 055503, Erratum-ibid. C72 (2005) 019902
c                        4.- returns d sigma/d Tmu d cos 
c                            using Eq. 10 from same ref.
c      HadTensorW: bilinear interpolation to give the Hadronic tensor from
c                  the grid
cccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine readhadtensor(name) 
      implicit real*8 (a,b,d-h,o-z)
      dimension htfull(5,120,120)
      common /hadtensorstor/htfull
      character*16 name

      open(unit=27,file=name)
      read(27,*)htfull

      return 
      end 

c OUTPUT VARIABLES
c 'diffCS' is the contribution of 2p2h to the double differential
c cross section d2sigma/(dTmu dcos_mu), units 10^{-41} cm^2/GeV
      subroutine diffCrossSection(inu,Enu,Tmu,xcos,diffCS)
      implicit real*8 (a-h,o-z)
      dimension xk(0:3),xkprima(0:3),wtotd(0:3,0:3),q(0:3)

      common/Qvalues/QvalueMeV,QvalueGeV
      parameter(pi=3.141592653589793d0,xmlepton=0.105658357d0,
     &               Gfermi=1.1664d-5)
c Gfermi is in GeV^(-2))

      facconv=0.19733d0**2*1.d15
      Qvalue=QvalueGeV
c       
      xsin=dsqrt(1.d0-xcos**2)
      anghalf=acos(xcos)/2.d0
      xcosh=cos(anghalf)
      xsinh=sin(anghalf)       
c      
      energylepton=Tmu+xmlepton        !!! final lepton energy
c	
      energyneutrino=Enu
c Four-momentum of the incoming neutrino
      xk(0)=energyneutrino
      xk(1)=0.d0
      xk(2)=0.d0
      xk(3)=energyneutrino
c      
      q0=energyneutrino-energylepton
      q0nucleus=q0-Qvalue
      
      if(q0nucleus.gt.0.d0)then
         xkprima(0)=energylepton
         xmodkprima=dsqrt(energylepton**2-xmlepton**2)
         xkprima(1)=xmodkprima*xsin
         xkprima(2)=0.d0
         xkprima(3)=xmodkprima*xcos
         call RestaFourVectors(xk,xkprima,q)
        q(0)=q0nucleus
        qm=sqrt(q(1)**2+q(2)**2+q(3)**2)
c
        call HadTensorW(q,wtotd)

        w1=wtotd(1,1)/2.d0
        w2=(wtotd(0,0)+wtotd(1,1)+q0**2/qm**2*(wtotd(3,3)-wtotd(1,1)) 
     &         -2.d0*q0/qm*wtotd(0,3))/2.d0
        w3=wtotd(1,2)/qm
        w4=(wtotd(3,3)-wtotd(1,1))/(2.d0*qm**2)
        w5=(wtotd(0,3)-q0/qm*(wtotd(3,3)-wtotd(1,1)))/qm

        if(inu.eq.2)w3=-w3
c 
        aux1= w1*xcos-w2/2.d0*xcos  +w3/2.d0*
     & (energylepton+xmodkprima-(energylepton+energyneutrino)*xcos)
     & +w4/2.d0*
     & (xmlepton**2*xcos+
     &    2.d0*energylepton*(energylepton+xmodkprima)*xsinh**2)-
     &  w5*(energylepton+xmodkprima)/2.d0
c
         aux0= 2.d0*w1*xsinh**2+w2*xcosh**2
     &             -w3*(energylepton+energyneutrino)*xsinh**2
     & + xmlepton**2/(energylepton*(energylepton+xmodkprima))*aux1
c
      diffCS=xmodkprima*energylepton*Gfermi**2*2.d0/pi*aux0*facconv !! in 10^{-41} cm^2/GeV

c diffCS=dsigma/(dcos(theta)dTmu)   !! in 10^{-41} cm^2/GeV	 
      else
         diffCS=0.d0
      endif
c
      return
      end
 



c substraction of two four-vectors
      subroutine RestaFourVectors(cp,cq,cpminusq)
      implicit real*8 (a-h,o-z)
      dimension cp(0:3),cq(0:3),cpminusq(0:3)

      do mu=0,3
         cpminusq(mu)=cp(mu)-cq(mu)
      enddo

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c uses symmetry properties of Had. Tensor. for the case where
c LAB system and q=(q0,0,0,qz)
c only a few (5) components are needed
c
c See e.g. Eq. (6) of Phys. Rev. C 73, 025504 (2006)
c              (20) of Phys.Rev. C70 (2004) 055503 ...
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        subroutine HadTensorW(q,wtotd)
	implicit complex*16 (c)
	implicit real*8 (a,b,d-h,o-z)
        dimension htfull(5,120,120),aux(5)
        dimension wtotd(0:3,0:3),q(0:3)
        common /hadtensorstor/htfull
c   
c minimal interpolation, better splines 
c     
         qmom=sqrt(q(1)**2+q(2)**2+q(3)**2)
         xiq=qmom/0.01d0
         iq=int(xiq)
         sq=xiq-iq
c
         xiq0=q(0)/0.01d0
         iq0=int(xiq0)
         sq0=xiq0-iq0
c care with limit cases
         if((iq.ge.1.and.iq.lt.120).and.(iq0.ge.1.and.iq0.lt.120))then
c
c reading tensor and interpolating
c
           do icounter=1,5
         aux(icounter)=htfull(icounter,iq0,iq)*(1.d0-sq)*(1.d0-sq0)+
     &                   htfull(icounter,iq0,iq+1)*sq*(1.d0-sq0)+
     &                   htfull(icounter,iq0+1,iq)*sq0*(1.d0-sq)+
     &                   htfull(icounter,iq0+1,iq+1)*sq*sq0
           enddo
         else
           do icounter=1,5
            aux(icounter)=0.d0
           enddo
         endif
c this could be improved later to make soft limits
c down to Lorentz indices and takes only relevant stuff
         wtotd(0,0)=aux(1)
         wtotd(0,3)=aux(2)
         wtotd(1,1)=aux(3)
         wtotd(1,2)=aux(4)
         wtotd(3,3)=aux(5)

          return
          end

         
